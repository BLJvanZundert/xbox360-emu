/* Add */
bool add(State *state, Instruction instr)
{
   return false;
}

/* Add Carrying */
bool addc(State *state, Instruction instr)
{
   return false;
}

/* Add Extended */
bool adde(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate */
bool addi(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying */
bool addic(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Carrying and Record */
bool addico(State *state, Instruction instr)
{
   return false;
}

/* Add Immediate Shifted */
bool addis(State *state, Instruction instr)
{
   return false;
}

/* Add to Minus One Extended */
bool addme(State *state, Instruction instr)
{
   return false;
}

/* Add to Zero Extended */
bool addze(State *state, Instruction instr)
{
   return false;
}

/* AND */
bool and(State *state, Instruction instr)
{
   return false;
}

/* AND with Complement */
bool andc(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate */
bool andio(State *state, Instruction instr)
{
   return false;
}

/* AND Immediate Shifted */
bool andiso(State *state, Instruction instr)
{
   return false;
}

/* Branch */
bool b(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional */
bool bc(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Count Register */
bool bcctr(State *state, Instruction instr)
{
   return false;
}

/* Branch Conditional to Link Register */
bool bclr(State *state, Instruction instr)
{
   return false;
}

/* Compare */
bool cmp(State *state, Instruction instr)
{
   return false;
}

/* Compare Immediate */
bool cmpi(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical */
bool cmpl(State *state, Instruction instr)
{
   return false;
}

/* Compare Logical Immediate */
bool cmpli(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Doubleword */
bool cntlzd(State *state, Instruction instr)
{
   return false;
}

/* Count Leading Zeros Word */
bool cntlzw(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND */
bool crand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register AND with Complement */
bool crandc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register Equivalent */
bool creqv(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NAND */
bool crnand(State *state, Instruction instr)
{
   return false;
}

/* Condition Register NOR */
bool crnor(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR */
bool cror(State *state, Instruction instr)
{
   return false;
}

/* Condition Register OR with Complement */
bool crorc(State *state, Instruction instr)
{
   return false;
}

/* Condition Register XOR */
bool crxor(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Flush */
bool dcbf(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Store */
bool dcbst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch */
bool dcbt(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Block Touch for Store */
bool dcbtst(State *state, Instruction instr)
{
   return false;
}

/* Data Cache Clear to Zero */
bool dcbz(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword */
bool divd(State *state, Instruction instr)
{
   return false;
}

/* Divide Doubleword Unsigned */
bool divdu(State *state, Instruction instr)
{
   return false;
}

/* Divide Word */
bool divw(State *state, Instruction instr)
{
   return false;
}

/* Divide Word Unsigned */
bool divwu(State *state, Instruction instr)
{
   return false;
}

/* External Control In Word Indexed */
bool eciwx(State *state, Instruction instr)
{
   return false;
}

/* External Control Out Word Indexed */
bool ecowx(State *state, Instruction instr)
{
   return false;
}

/* Enforce In-Order Execution of I/O */
bool eieio(State *state, Instruction instr)
{
   return false;
}

/* Equivalent */
bool eqv(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Byte */
bool extsb(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Halfword */
bool extsh(State *state, Instruction instr)
{
   return false;
}

/* Extend Sign Word */
bool extsw(State *state, Instruction instr)
{
   return false;
}

/* Floating Absolute Value */
bool fabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Add (Double-Precision) */
bool fadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Add Single */
bool fadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert from Integer Doubleword */
bool fcfid(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Ordered */
bool fcmpo(State *state, Instruction instr)
{
   return false;
}

/* Floating Compare Unordered */
bool fcmpu(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword */
bool fctid(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Doubleword with round toward Zero */
bool fctidz(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word */
bool fctiw(State *state, Instruction instr)
{
   return false;
}

/* Floating Convert to Integer Word with round toward Zero */
bool fctiwz(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide (Double-Precision) */
bool fdiv(State *state, Instruction instr)
{
   return false;
}

/* Floating Divide Single */
bool fdivs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add (Double-Precision) */
bool fmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Add Single */
bool fmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Move Register (Double-Precision) */
bool fmr(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract (Double-Precision) */
bool fmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply-Subtract Single */
bool fmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply (Double-Precision) */
bool fmul(State *state, Instruction instr)
{
   return false;
}

/* Floating Multiply Single */
bool fmuls(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Absolute Value */
bool fnabs(State *state, Instruction instr)
{
   return false;
}

/* Floating Negate */
bool fneg(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add (Double-Precision) */
bool fnmadd(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Add Single */
bool fnmadds(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract (Double-Precision) */
bool fnmsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Negative Multiply-Subtract Single */
bool fnmsubs(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Estimate Single */
bool fres(State *state, Instruction instr)
{
   return false;
}

/* Floating Round to Single */
bool frsp(State *state, Instruction instr)
{
   return false;
}

/* Floating Reciprocal Square Root Estimate */
bool frsqrte(State *state, Instruction instr)
{
   return false;
}

/* Floating Select */
bool fsel(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root (Double-Precision) */
bool fsqrt(State *state, Instruction instr)
{
   return false;
}

/* Floating Square Root Single */
bool fsqrts(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract (Double-Precision) */
bool fsub(State *state, Instruction instr)
{
   return false;
}

/* Floating Subtract Single */
bool fsubs(State *state, Instruction instr)
{
   return false;
}

/* Instruction Cache Block Invalidate */
bool icbi(State *state, Instruction instr)
{
   return false;
}

/* Instruction Synchronize */
bool isync(State *state, Instruction instr)
{
   return false;
}

/* Kernel Function Call */
bool krncall(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero */
bool lbz(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update */
bool lbzu(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero with Update Indexed */
bool lbzux(State *state, Instruction instr)
{
   return false;
}

/* Load Byte and Zero Indexed */
bool lbzx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword */
bool ld(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword and Reserve Indexed */
bool ldarx(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update */
bool ldu(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword with Update Indexed */
bool ldux(State *state, Instruction instr)
{
   return false;
}

/* Load Doubleword Indexed */
bool ldx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double */
bool lfd(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update */
bool lfdu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double with Update Indexed */
bool lfdux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Double Indexed */
bool lfdx(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single */
bool lfs(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update */
bool lfsu(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single with Update Indexed */
bool lfsux(State *state, Instruction instr)
{
   return false;
}

/* Load Floating-Point Single Indexed */
bool lfsx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic */
bool lha(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update */
bool lhau(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic with Update Indexed */
bool lhaux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Algebraic Indexed */
bool lhax(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword Byte-Reverse Indexed */
bool lhbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero */
bool lhz(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update */
bool lhzu(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero with Update Indexed */
bool lhzux(State *state, Instruction instr)
{
   return false;
}

/* Load Halfword and Zero Indexed */
bool lhzx(State *state, Instruction instr)
{
   return false;
}

/* Load Multiple Word */
bool lmw(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Immediate */
bool lswi(State *state, Instruction instr)
{
   return false;
}

/* Load String Word Indexed */
bool lswx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic */
bool lwa(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Reserve Indexed */
bool lwarx(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic with Update Indexed */
bool lwaux(State *state, Instruction instr)
{
   return false;
}

/* Load Word Algebraic Indexed */
bool lwax(State *state, Instruction instr)
{
   return false;
}

/* Load Word Byte-Reverse Indexed */
bool lwbrx(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero */
bool lwz(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update */
bool lwzu(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero with Update Indexed */
bool lwzux(State *state, Instruction instr)
{
   return false;
}

/* Load Word and Zero Indexed */
bool lwzx(State *state, Instruction instr)
{
   return false;
}

/* Move Condition Register Field */
bool mcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register from FPSCR */
bool mcrfs(State *state, Instruction instr)
{
   return false;
}

/* Move from Condition Register */
bool mfcr(State *state, Instruction instr)
{
   return false;
}

/* Move from FPSCR */
bool mffs(State *state, Instruction instr)
{
   return false;
}

/* Move from Machine State Register */
bool mfmsr(State *state, Instruction instr)
{
   return false;
}

/* Move from One Condition Register Field */
bool mfocrf(State *state, Instruction instr)
{
   return false;
}

/* Move from Special-Purpose Register */
bool mfspr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register */
bool mfsr(State *state, Instruction instr)
{
   return false;
}

/* Move from Segment Register Indirect */
bool mfsrin(State *state, Instruction instr)
{
   return false;
}

/* Move from Time Base */
bool mftb(State *state, Instruction instr)
{
   return false;
}

/* Move to Condition Register Fields */
bool mtcrf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 0 */
bool mtfsb0(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Bit 1 */
bool mtfsb1(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Fields */
bool mtfsf(State *state, Instruction instr)
{
   return false;
}

/* Move to FPSCR Field Immediate */
bool mtfsfi(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register */
bool mtmsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Machine State Register Doubleword */
bool mtmsrd(State *state, Instruction instr)
{
   return false;
}

/* Move to One Condition Register Field */
bool mtocrf(State *state, Instruction instr)
{
   return false;
}

/* Move to Special-Purpose Register */
bool mtspr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register */
bool mtsr(State *state, Instruction instr)
{
   return false;
}

/* Move to Segment Register Indirect */
bool mtsrin(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword */
bool mulhd(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Doubleword Unsigned */
bool mulhdu(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word */
bool mulhw(State *state, Instruction instr)
{
   return false;
}

/* Multiply High Word Unsigned */
bool mulhwu(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Doubleword */
bool mulld(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Immediate */
bool mulli(State *state, Instruction instr)
{
   return false;
}

/* Multiply Low Word */
bool mullw(State *state, Instruction instr)
{
   return false;
}

/* NAND */
bool nand(State *state, Instruction instr)
{
   return false;
}

/* Negate */
bool neg(State *state, Instruction instr)
{
   return false;
}

/* NOR */
bool nor(State *state, Instruction instr)
{
   return false;
}

/* OR */
bool or(State *state, Instruction instr)
{
   return false;
}

/* OR with Complement */
bool orc(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate */
bool ori(State *state, Instruction instr)
{
   return false;
}

/* OR Immediate Shifted */
bool oris(State *state, Instruction instr)
{
   return false;
}

/* Return from Interrupt Doubleword */
bool rfid(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Left */
bool rldcl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword then Clear Right */
bool rldcr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear */
bool rldic(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Left */
bool rldicl(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Clear Right */
bool rldicr(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Doubleword Immediate then Mask Insert */
bool rldimi(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then Mask Insert */
bool rlwimi(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word Immediate then AND with Mask */
bool rlwinm(State *state, Instruction instr)
{
   return false;
}

/* Rotate Left Word then AND with Mask */
bool rlwnm(State *state, Instruction instr)
{
   return false;
}

/* System Call */
bool sc(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate All */
bool slbia(State *state, Instruction instr)
{
   return false;
}

/* SLB Invalidate Entry */
bool slbie(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry ESID */
bool slbmfee(State *state, Instruction instr)
{
   return false;
}

/* SLB Move From Entry VSID */
bool slbmfev(State *state, Instruction instr)
{
   return false;
}

/* SLB Move To Entry */
bool slbmte(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Doubleword */
bool sld(State *state, Instruction instr)
{
   return false;
}

/* Shift Left Word */
bool slw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword */
bool srad(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Doubleword Immediate */
bool sradi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word */
bool sraw(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Algebraic Word Immediate */
bool srawi(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Doubleword */
bool srd(State *state, Instruction instr)
{
   return false;
}

/* Shift Right Word */
bool srw(State *state, Instruction instr)
{
   return false;
}

/* Store Byte */
bool stb(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update */
bool stbu(State *state, Instruction instr)
{
   return false;
}

/* Store Byte with Update Indexed */
bool stbux(State *state, Instruction instr)
{
   return false;
}

/* Store Byte Indexed */
bool stbx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword */
bool std(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Conditional Indexed */
bool stdcx(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update */
bool stdu(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword with Update Indexed */
bool stdux(State *state, Instruction instr)
{
   return false;
}

/* Store Doubleword Indexed */
bool stdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double */
bool stfd(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update */
bool stfdu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double with Update Indexed */
bool stfdux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Double Indexed */
bool stfdx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point as Integer Word Indexed */
bool stfiwx(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single */
bool stfs(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update */
bool stfsu(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single with Update Indexed */
bool stfsux(State *state, Instruction instr)
{
   return false;
}

/* Store Floating-Point Single Indexed */
bool stfsx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword */
bool sth(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Byte-Reverse Indexed */
bool sthbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update */
bool sthu(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword with Update Indexed */
bool sthux(State *state, Instruction instr)
{
   return false;
}

/* Store Halfword Indexed */
bool sthx(State *state, Instruction instr)
{
   return false;
}

/* Store Multiple Word */
bool stmw(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Immediate */
bool stswi(State *state, Instruction instr)
{
   return false;
}

/* Store String Word Indexed */
bool stswx(State *state, Instruction instr)
{
   return false;
}

/* Store Word */
bool stw(State *state, Instruction instr)
{
   return false;
}

/* Store Word Byte-Reverse Indexed */
bool stwbrx(State *state, Instruction instr)
{
   return false;
}

/* Store Word Conditional Indexed */
bool stwcx(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update */
bool stwu(State *state, Instruction instr)
{
   return false;
}

/* Store Word with Update Indexed */
bool stwux(State *state, Instruction instr)
{
   return false;
}

/* Store Word Indexed */
bool stwx(State *state, Instruction instr)
{
   return false;
}

/* Subtract From */
bool subf(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Carrying */
bool subfc(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Extended */
bool subfe(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Immediate Carrying */
bool subfic(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Minus One Extended */
bool subfme(State *state, Instruction instr)
{
   return false;
}

/* Subtract From Zero Extended */
bool subfze(State *state, Instruction instr)
{
   return false;
}

/* Synchronize */
bool sync(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword */
bool td(State *state, Instruction instr)
{
   return false;
}

/* Trap Doubleword Immediate */
bool tdi(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate All */
bool tlbia(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry */
bool tlbie(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Invalidate Entry Local */
bool tlbiel(State *state, Instruction instr)
{
   return false;
}

/* Translation Lookaside Buffer Synchronize */
bool tlbsync(State *state, Instruction instr)
{
   return false;
}

/* Trap Word */
bool tw(State *state, Instruction instr)
{
   return false;
}

/* Trap Word Immediate */
bool twi(State *state, Instruction instr)
{
   return false;
}

/* XOR */
bool xor(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate */
bool xori(State *state, Instruction instr)
{
   return false;
}

/* XOR Immediate Shifted */
bool xoris(State *state, Instruction instr)
{
   return false;
}

